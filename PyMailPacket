#!/usr/bin/env python2.7
# vim: set fileencoding=<utf-8> :
""" PyMailPacket for x/84, http://github.com/jquast/x84
    (c) 2015 Michael Griffin <mrmisticismo@hotmail.com>
    http://github.com/m-griffin/PyMailPacket

    This is a FidoNet Echomail Scanner / Tosser for x84 bbs.
    This will mimic the basic functionality of Crashmail for
    Reading and Writing mail packets.
"""

__author__ = "Michael Griffin"
__copyright__ = "Copyright 2015"
__credits__ = ["Jeff Quast"]
__license__ = "MIT"
__version__ = "1.0.0"
__status__ = "Prototype"

import ConfigParser
import collections
import zipfile
import struct
import glob
import os


_struct_packet_header_fields = [
    # Structure Size 58
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'year'),
    ('H', 'month'),
    ('H', 'day'),
    ('H', 'hour'),
    ('H', 'minute'),
    ('H', 'second'),
    ('H', 'baud'),
    ('H', 'packet_type'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('B', 'prod_code_low'),
    ('B', 'revision_major'),
    ('8s', 'password'),
    ('H', 'origin_zone'),
    ('H', 'destination_zone'),
    ('H', 'aux_network'),
    ('H', 'capWordA'),
    ('B', 'prod_code_hi'),
    ('B', 'pRevMinor'),
    ('H', 'capWordB'),
    ('H', 'origin_zone2'),
    ('H', 'destination_zone2'),
    ('H', 'origin_point'),
    ('H', 'destination_point'),
    ('L', 'prod_data')
]
_struct_fidonet_packet = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_packet_header_fields))
FidonetPacketHeader = collections.namedtuple(
    'FidonetPacketHeader', [field_name for _, field_name in _struct_packet_header_fields])

_struct_message_header_fields = [
    # Structure Size 14
    ('H', 'message_type'),
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('H', 'attributes_flags'),
    ('H', 'cost'),
]
_struct_fidonet_message_header = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_message_header_fields))
FidonetMessageHeader = collections.namedtuple(
    'FidonetMessageHeader', [field_name for _, field_name in _struct_message_header_fields])


def read_cstring(file_object, offset):
    # Function to read text up to null terminator
    new_string = ""
    # jump to offset.
    assert isinstance(offset, object)
    file_object.seek(offset)
    while True:
        # read the file object
        byte = file_object.read(1)
        if not byte:
            break
        if byte in '\x00':
            # Break on Null Terminated
            break

        new_string += str(byte)
    return new_string


def read_kluge_string(file_object, offset):
    # Function to read text up to terminator
    new_string = ""
    # jump to offset.
    assert isinstance(offset, object)
    file_object.seek(offset)
    while True:
        # read the file object
        byte = file_object.read(1)
        if not byte:
            break
        if byte in '0x9d':
            # Terminated with 157 for Kludge Lines
            break

        new_string += str(byte)
    return new_string


def read_message_text(file_object, offset):
    # Function to read message text up to null terminator
    assert isinstance(offset, object)
    file_object.seek(offset)

    my_list = []
    for chunk in iter(lambda: file_object.read(1), ''):
        if chunk in '\x00':
            break
            
        # elif chunk in ('\x01', '\x9d', '0x9d'):
        my_list.append(chunk)

    return my_list


def main():
    # Get Path to Fido Packets from Config file.
    config = ConfigParser.ConfigParser()
    config.read(u'mailpacket.conf')
    inbound_folder = config.get(u'mailpacket', u'inbound')
    unpack_folder = config.get(u'mailpacket', u'unpack')

    assert os.path.isdir(inbound_folder)

    for file_path_zip in glob.glob(os.path.join(inbound_folder, u'*.*')):
        # Uncompress packet bundles, then loop to read packet/message headers/messages
        try:
            with zipfile.ZipFile(file_path_zip) as zip_obj:
                zip_obj.extractall(unpack_folder)

            packet_path = os.path.join(unpack_folder, u'*.pkt')
            print packet_path
            assert os.path.isdir(unpack_folder)

            total_message_count = 0

            for file_name in os.listdir(unpack_folder):
                # Parse Each Packet for the Header first.
                print u'Mail Packet: ' + file_name

                # loop Each message inside of a packet
                fido_object = open(os.path.join(unpack_folder, file_name), 'rb')

                try:
                    # make Sure we don't read past the end of the file!
                    packet_header_read = fido_object.read()[:58]
                except EOFError:
                        # move to next packet if were at the end.
                        break

                if not packet_header_read:
                    break

                # Make sure we have correct size! Otherwise were done.
                # print 'packet_header_read len: ' + str(len(packet_header_read))
                if len(packet_header_read) < 58:
                        break

                # Read the Packet Header
                fido_header = FidonetPacketHeader(
                    *struct.unpack(_struct_fidonet_packet, packet_header_read))

                assert isinstance(fido_header, object)
                print fido_header

                message_count = 0

                offset = struct.calcsize(_struct_fidonet_packet)
                while True:

                    # Reset Position to right after Fido Header
                    fido_object.seek(offset)

                    # Try to parse the message header
                    try:
                        # make Sure we don't read past the end of the file!
                        message_header_read = fido_object.read()[:14]
                    except EOFError:
                        # move to next packet if were at the end.
                        break

                    if not packet_header_read:
                        break

                    # Make sure we have correct size! Otherwise were done.
                    # print 'message_header_read len: ' + str(len(message_header_read))
                    if len(message_header_read) < 14:
                        break

                    # Read the Message Header
                    fido_message_header = FidonetMessageHeader(
                        *struct.unpack(_struct_fidonet_message_header, message_header_read))

                    assert isinstance(fido_message_header, object)
                    print fido_message_header

                    # Update The Offset
                    offset += struct.calcsize(_struct_fidonet_message_header)

                    # Next move back to the next position
                    """ Next we need to parse For '\x00' terminated strings.
                    ('20s', 'dateTime'),
                    ('36s', 'toUsername'),
                    ('36s', 'fromUsername'),
                    ('72s', 'subject')
                    """

                    # Use cleaner way to keep track of offset!!
                    new_string = read_cstring(fido_object, offset)
                    offset += len(new_string) + 1
                    print u'DateTime: ' + new_string

                    new_string = read_cstring(fido_object, offset)
                    offset += len(new_string) + 1
                    print u'To (UserName): ' + new_string

                    new_string = read_cstring(fido_object, offset)
                    offset += len(new_string) + 1
                    print u'From (UserName): ' + new_string

                    new_string = read_cstring(fido_object, offset)
                    offset += len(new_string) + 1
                    print u'Subject: ' + new_string

                    # We now read the entire message up to null terminator
                    # some fields terminate with 0x9d, and start with
                    # ie AREA:%s \x0d or \r!
                    # Other fields start with \x01: Kludge Lines
                    # "\x01""PID:",5
                    # "\x01""MSGID:",7
                    # "\x01""REPLY:",7
                    # "\x01""FLAGS:",7
                    # "\x01""INTL",5
                    # "\x01""TOPT",5
                    # "\x01""FMPT",5
                    # SEEN-BY:
                    # "\01" "PATH: "
                    # if(flagsbuf[0])
                    # strcat((char *)flagsbuf,(char *)"\x0d");
                    # " * Origin: ",11
                    # TID

                    # Read in entire text of message (parse out after, kludge and tag/origin lines)
                    message_list = read_message_text(fido_object, offset)
                    offset += len(message_list) + 1
                    print message_list

                    message_count += 1
                    total_message_count += 1

                # Cleanup for next run
                fido_object.close()
                print ''
                print u'Total Messages This Packet -> ' + str(message_count)
                print u'Total Messages Count -> ' + str(total_message_count)

        finally:
            # Clear the unpack_folder here lateron, leave for testing, just overwrites!
            print u'Done'


if __name__ == '__main__':
    main()
