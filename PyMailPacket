#!/usr/bin/env python2.7
# vim: set fileencoding=<utf-8> :
""" PyMailPacket for x/84, http://github.com/jquast/x84
    (c) 2015 Michael Griffin <mrmisticismo@hotmail.com>
    http://github.com/m-griffin/PyMailPacket

    This is a FidoNet Echomail Scanner / Tosser for x84 bbs.
    This will mimic the basic functionality of Crashmail for
    Reading and Writing mail packets.
"""

__author__ = "Michael Griffin"
__copyright__ = "Copyright 2015"
__credits__ = ["Jeff Quast"]
__license__ = "MIT"
__version__ = "1.0.0"
__status__ = "Prototype"


import ConfigParser
import collections
import zipfile
import struct
import glob
import os

import ctypes
c_uint8 = ctypes.c_uint8


_struct_packet_header_fields = [
    # Structure Size 58
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'year'),
    ('H', 'month'),
    ('H', 'day'),
    ('H', 'hour'),
    ('H', 'minute'),
    ('H', 'second'),
    ('H', 'baud'),
    ('H', 'packet_type'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('B', 'prod_code_low'),
    ('B', 'revision_major'),
    ('8s', 'password'),
    ('H', 'origin_zone'),
    ('H', 'destination_zone'),
    ('H', 'aux_network'),
    ('H', 'capWordA'),
    ('B', 'prod_code_hi'),
    ('B', 'revision_minor'),
    ('H', 'capWordB'),
    ('H', 'origin_zone2'),
    ('H', 'destination_zone2'),
    ('H', 'origin_point'),
    ('H', 'destination_point'),
    ('L', 'prod_data')
]

_struct_fidonet_packet = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_packet_header_fields))
FidonetPacketHeader = collections.namedtuple(
    'FidonetPacketHeader', [field_name for _, field_name in _struct_packet_header_fields])


class FlagBits(ctypes.LittleEndianStructure):
    # Bit field structure for message header flags
    _fields_ = [
        ('private',      c_uint8, 1),  # asByte & 1
        ('crash',        c_uint8, 1),  # asByte & 2
        ('received',     c_uint8, 1),  # asByte & 4
        ('sent',         c_uint8, 1),  # asByte & 8
        ('file_attach',  c_uint8, 1),  # asByte & 16
        ('in_transit',   c_uint8, 1),  # asByte & 32
        ('orphan',       c_uint8, 1),  # asByte & 64
        ('kill_sent',    c_uint8, 1),  # asByte & 128
    ]


class FlagBits2(ctypes.LittleEndianStructure):
    # Bit field structure for message header flags
    _fields_ = [
        ('local',        c_uint8, 1),  # asByte & 256
        ('hold',         c_uint8, 1),  # asByte & 512
        ('unused',       c_uint8, 1),  # asByte & 1024
        ('file_request', c_uint8, 1),  # asByte & 2048
        ('want_receipt', c_uint8, 1),  # asByte & 4096
        ('is_receipt',   c_uint8, 1),  # asByte & 8192
        ('audit',        c_uint8, 1),  # asByte & 16384
        ('file_update',  c_uint8, 1),  # asByte & 32768
    ]


class Flags(ctypes.Union):
    _fields_ = [('bit', FlagBits),
                ('in_value', c_uint8)]


class Flags2(ctypes.Union):
    _fields_ = [('bit', FlagBits2),
                ('in_value', c_uint8)]


class SetFlags():
    # Class to Bundle Settings of Bit Flags for Attributes
    field  = None
    field2 = None

    def __init__(self, field, field2):
        # get flags from message header
        self.field = field
        self.field2 = field2
        self.set_flags()

    def set_flags(self):
        attributes = Flags()
        attributes.in_value = self.field

        attributes2 = Flags2()
        attributes2.in_value = self.field2

        # Not the most elegant!  appears to work.
        # However i want more verification.
        print attributes.bit.private
        print attributes.bit.crash
        print attributes.bit.received
        print attributes.bit.sent
        print attributes.bit.file_attach
        print attributes.bit.in_transit
        print attributes.bit.orphan
        print attributes.bit.kill_sent
        print ' '
        print attributes2.bit.local
        print attributes2.bit.hold
        print attributes2.bit.unused
        print attributes2.bit.file_request
        print attributes2.bit.want_receipt
        print attributes2.bit.is_receipt
        print attributes2.bit.audit
        print attributes2.bit.file_update


_struct_message_header_fields = [
    # Structure Size 14
    ('H', 'message_type'),
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('B', 'attributes_flags1'),
    ('B', 'attributes_flags2'),
    ('H', 'cost'),
]
_struct_fidonet_message_header = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_message_header_fields))
FidonetMessageHeader = collections.namedtuple(
    'FidonetMessageHeader', [field_name for _, field_name in _struct_message_header_fields])


def read_cstring(file_object, offset):
    # Function to read text up to null terminator
    new_string = ""
    # jump to offset.
    assert isinstance(offset, object)
    file_object.seek(offset)
    while True:
        # read the file object
        byte = file_object.read(1)
        if not byte:
            break
        if byte in '\x00':
            # Break on Null Terminated
            break

        new_string += str(byte)
    return new_string


def read_message_text(file_object, offset):
    # Function to read message text up to null terminator
    assert isinstance(offset, object)
    file_object.seek(offset)

    message_string = ""
    for chunk in iter(lambda: file_object.read(1), ''):
        if chunk in '\x00':
            break

        message_string += chunk
    return message_string


class Message():
    # Message Object that will be pasted into.
    def __init__(self, data, user_to, user_from, subject):
        """

        :type self: str
        """
        self.user_to = user_to
        self.user_from = user_from
        self.subject = subject
        self.area = None
        self.tag_line = None
        self.origin_line = None
        self.kludge_lines = collections.OrderedDict()
        self.seen_by = []
        self.raw_data = data
        # Clean Message Text, Split with CR, remove any LF!
        self.message_lines = [x.strip('\n') for x in self.raw_data.split('\r')]
        # Initial method when we enter the class.
        self.parse_lines()

    def add_kludge(self, line):
        # Separates Kludge Lines into An Array of Fields
        key, value = line.split(None, 1)
        key = key[1:]

        if key in self.kludge_lines:
            assert isinstance(value, object)
            self.kludge_lines[key].append(value)
        else:
            self.kludge_lines[key] = [value]

    def parse_lines(self):
        # Breaks up the message data into fields
        stage = 1
        message_body = []

        for line in self.message_lines:
            if stage == 1:
                # Start and Middle of Message Text
                if line.startswith('AREA:'):
                    self.area = line.split(':')[1]
                    print 'Area : ' + self.area

                elif line.startswith('\x01'):
                    self.add_kludge(line.strip())

                elif line.startswith('--- '):
                    # Tracking Tag Lines might be a little much!
                    self.tag_line = line
                    # Leave Tag Line in message text
                    message_body.append(line)

                elif line.startswith(' * Origin:'):
                    # note some systems like Synchronet doesn't use * for origin!!
                    # So much for standards!
                    # need to put range in for this!! +3, 8
                    self.origin_line = line
                    # Leave Tag Line in message text
                    message_body.append(line)
                    stage = 2

                else:
                    message_body.append(line)

            elif stage == 2:
                # Stage 2 After Message Text
                if line.startswith('\x01'):
                    self.add_kludge(line)

                elif line.startswith('SEEN-BY:'):
                    self.seen_by.append(line)

                elif len(line) == 0:
                    pass

                else:
                    raise ValueError('Unexpected: %s' % line)

        self.message_lines = message_body

    def __str__(self):
        # Check this, should swap \r ? -MF
        """
        :rtype : str
        """
        return '\n'.join(self.message_lines) + '\n' + str(self.kludge_lines)

    def serialize(self):
        # Build The Message for Writing out to Packet
        lines = []

        if self.area:
            lines.append('AREA:%s' % self.area)

        for key, kludge_value in self.kludge_lines.items():
            for value in kludge_value:
                # Check if these needs \r at end of line!!
                lines.append('\x01%s %s' % (key, value))

        lines.extend(self.message_lines)

        if self.origin_line:
            lines.append(self.origin_line)

        lines.extend(self.seen_by)

        # return fts0001.MessageBody.build('\r'.join(lines))


def main():
    # Get Path to Fido Packets from Config file.
    config = ConfigParser.ConfigParser()
    config.read(u'mailpacket.conf')
    inbound_folder = config.get(u'mailpacket', u'inbound')
    unpack_folder = config.get(u'mailpacket', u'unpack')

    print inbound_folder
    assert os.path.isdir(inbound_folder)

    for file_path_zip in glob.glob(os.path.join(inbound_folder, u'*.*')):
        # Uncompress packet bundles, then loop to read packet/message headers/messages
        try:
            with zipfile.ZipFile(file_path_zip) as zip_obj:
                zip_obj.extractall(unpack_folder)

            packet_path = os.path.join(unpack_folder, u'*.pkt')
            print packet_path
            assert os.path.isdir(unpack_folder)

            total_message_count = 0

            for file_name in os.listdir(unpack_folder):
                # Parse Each Packet for the Header first.
                print u'\r\nMail Packet: ' + file_name

                # Open then Parse Each Packet
                fido_object = open(os.path.join(unpack_folder, file_name), 'rb')

                try:
                    # make Sure we don't read past the end of the file!
                    packet_header_read = fido_object.read()[:58]
                except EOFError:
                    # move to next packet if were at the end.
                    break

                if not packet_header_read:
                    # move to next packet, log error here
                    break

                # Make sure we have correct size! Otherwise were done.
                # print 'packet_header_read len: ' + str(len(packet_header_read))
                if len(packet_header_read) < 58:
                    # End of File can have (2) Bytes, catch this.
                    break

                # Read the Packet Header
                fido_header = FidonetPacketHeader(
                    *struct.unpack(_struct_fidonet_packet, packet_header_read))

                assert isinstance(fido_header, object)
                print fido_header

                message_count = 0

                offset = struct.calcsize(_struct_fidonet_packet)
                while True:

                    # Reset Position to right after Fido Header
                    fido_object.seek(offset)

                    # Try to parse the message header
                    try:
                        # make Sure we don't read past the end of the file!
                        message_header_read = fido_object.read()[:14]
                    except EOFError:
                        # move to next packet if were at the end.
                        break

                    if not packet_header_read:
                        # move to next packet, log error here
                        break

                    # Make sure we have correct size! Otherwise were done.
                    # print 'message_header_read len: ' + str(len(message_header_read))
                    if len(message_header_read) < 14:
                        # End of File can have (2) Bytes, catch this.
                        break

                    # Read the Message Header
                    fido_message_header = FidonetMessageHeader(
                        *struct.unpack(_struct_fidonet_message_header, message_header_read))

                    assert isinstance(fido_message_header, object)
                    print fido_message_header
                    print ''

                    # Test Message Header Flags, that we are reading correctly!!
                    # WIP
                    SetFlags(fido_message_header.attributes_flags1,
                             fido_message_header.attributes_flags2)

                    # Update The Offset
                    offset += struct.calcsize(_struct_fidonet_message_header)

                    # Next move back to the next position
                    """ Next we need to parse For '\x00' terminated strings.
                    ('20s', 'dateTime'),
                    ('36s', 'toUsername'),
                    ('36s', 'fromUsername'),
                    ('72s', 'subject')
                    """

                    # Use cleaner way to keep track of offset!!
                    date_time_string = read_cstring(fido_object, offset)
                    offset += len(date_time_string) + 1
                    print u'DateTime: ' + date_time_string

                    username_to = read_cstring(fido_object, offset)
                    offset += len(username_to) + 1
                    print u'To (UserName): ' + username_to

                    username_from = read_cstring(fido_object, offset)
                    offset += len(username_from) + 1
                    print u'From (UserName): ' + username_from

                    subject_string = read_cstring(fido_object, offset)
                    offset += len(subject_string) + 1
                    print u'Subject: ' + subject_string

                    # We now read the entire message up to null terminator
                    message_string = read_message_text(fido_object, offset)
                    offset += len(message_string) + 1

                    # Breaks up the message ans seperates out kludge lines from text.
                    print Message(message_string, username_to, username_from, subject_string)

                    message_count += 1
                    total_message_count += 1

                # Cleanup for next run
                fido_object.close()
                print ''
                print u'Total Messages This Packet -> ' + str(message_count)
                print u'Total Messages Count       -> ' + str(total_message_count)

        finally:
            # Clear the unpack_folder here later on, leave for testing, just overwrites!
            print u'Done'


if __name__ == '__main__':
    main()
