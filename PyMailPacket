#!/usr/bin/env python2.7
# vim: set fileencoding=<utf-8> :
""" PyMailPacket for x/84, http://github.com/jquast/x84
    (c) 2015 Michael Griffin <mrmisticismo@hotmail.com>
    http://github.com/m-griffin/PyMailPacket

    This is a FidoNet Echomail Scanner / Tosser for x84 bbs.
    This will mimic the basic functionality of Crashmail for
    Reading and Writing mail packets.
"""

__author__ = "Michael Griffin"
__copyright__ = "Copyright 2015"
__credits__ = ["Jeff Quast"]
__license__ = "MIT"
__version__ = "1.0.0"
__status__ = "Prototype"

import ConfigParser
import collections
import zipfile
import struct
import glob
import os


_struct_packet_header_fields = [
    # Structure Size 58
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'year'),
    ('H', 'month'),
    ('H', 'day'),
    ('H', 'hour'),
    ('H', 'minute'),
    ('H', 'second'),
    ('H', 'baud'),
    ('H', 'packet_type'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('B', 'prod_code_low'),
    ('B', 'revision_major'),
    ('8s', 'password'),
    ('H', 'origin_zone'),
    ('H', 'destination_zone'),
    ('H', 'aux_network'),
    ('H', 'capWordA'),
    ('B', 'prod_code_hi'),
    ('B', 'pRevMinor'),
    ('H', 'capWordB'),
    ('H', 'origin_zone2'),
    ('H', 'destination_zone2'),
    ('H', 'origin_point'),
    ('H', 'destination_point'),
    ('L', 'prod_data')
]
_struct_fidonet_packet = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_packet_header_fields))
FidonetPacketHeader = collections.namedtuple(
    'FidonetPacketHeader', [field_name for _, field_name in _struct_packet_header_fields])

_struct_message_header_fields = [
    # Structure Size 14
    ('H', 'message_type'),
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('H', 'attributes_flags'),
    ('H', 'cost'),
]
_struct_fidonet_message_header = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_message_header_fields))
FidonetMessageHeader = collections.namedtuple(
    'FidonetMessageHeader', [field_name for _, field_name in _struct_message_header_fields])


def read_cstring(file_object, offset):
    # Function to read text up to null terminator
    new_string = ""
    # jump to offset.
    assert isinstance(offset, object)
    file_object.seek(offset)
    while True:
        # read the file object
        byte = file_object.read(1)
        if not byte:
            break
        if byte in '\x00':
            # Break on Null Terminated
            break

        new_string += str(byte)
    return new_string


''' read_kluge_string Wip, this isn't correct'''


def read_kluge_string(file_object, offset):
    # Function to read text up to terminator
    new_string = ""
    # jump to offset.
    assert isinstance(offset, object)
    file_object.seek(offset)
    while True:
        # read the file object
        byte = file_object.read(1)
        if not byte:
            break
        if byte in '0x9d':
            # Terminated with 157 for Kludge Lines
            break

        new_string += str(byte)
    return new_string


def read_message_text(file_object, offset):
    # Function to read message text up to null terminator
    assert isinstance(offset, object)
    file_object.seek(offset)

    # my_list = []
    message_string = ""
    for chunk in iter(lambda: file_object.read(1), ''):
        if chunk in '\x00':
            break

        # elif chunk in ('\x01', '\x9d', '0x9d'):
        # my_list.append(chunk)
        message_string += chunk

    return message_string


class Message(object):
    # Message Object that will be pasted into.
    def __init__(self, data, user_to, user_from, subject):
        """

        :type self: str
        """
        self.user_to = user_to
        self.user_from = user_from
        self.subject = subject
        self.area = None
        self.origin_line = None
        self.kludge_lines = collections.OrderedDict()
        self.seen_by = []
        self.path = []
        self.raw_data = data
        # Clean Message Text, Split with CR, remove any LF!
        self.message_lines = [x.strip('\n') for x in self.raw_data.split('\r')]
        self.parse_lines()

    def add_kludge(self, line):
        # Separates Kludge Lines into An Array of Fields
        k, v = line.split(None, 1)
        k = k[1:]

        if k in self.kludge_lines:
            assert isinstance(v, object)
            self.kludge_lines[k].append(v)
        else:
            self.kludge_lines[k] = [v]

    def parse_lines(self):
        # Breaks up the message data into fields
        stage = 1
        message_body = []

        i = 0
        while i < len(self.message_lines):
            line = self.message_lines[i]

            # print 'stage 1: '

            if line.startswith('AREA:'):
                self.area = line.split(':')[1]
                print 'Area : ' + self.area
                i += 1
                continue

            if stage == 1:
                # print 'stage 2'
                if line.startswith('\x01'):
                    self.add_kludge(line.strip())
                elif line.startswith(' * Origin:'):
                    self.origin_line = line
                    stage = 2
                else:
                    message_body.append(line)

            elif stage == 2:
                # print 'stage 3'
                if line.startswith('\x01'):
                    self.add_kludge(line)
                elif line.startswith('SEEN-BY:'):
                    self.seen_by.append(line)
                elif line.startswith('\01'):
                    self.path = line
                elif len(line) == 0:
                    pass
                else:
                    raise ValueError('Unexpected: %s' % line)
            i += 1

        self.message_lines = message_body

    def __str__(self):
        # Check this, should swap \r ? -MF
        """

        :rtype : str
        """
        return '\n'.join(self.message_lines) + '\n' + self.origin_line

    def serialize(self):
        # Build The Message for Writing out to Packet
        lines = []

        if self.area:
            lines.append('AREA:%s' % self.area)

        for k, vv in self.kludge_lines.items():
            for v in vv:
                lines.append('\x01%s %s' % (k, v))

        lines.extend(self.message_lines)

        if self.origin_line:
            lines.append(self.origin_line)

        lines.extend(self.seen_by)

        # return fts0001.MessageBody.build('\r'.join(lines))


def main():
    # Get Path to Fido Packets from Config file.
    config = ConfigParser.ConfigParser()
    config.read(u'mailpacket.conf')
    inbound_folder = config.get(u'mailpacket', u'inbound')
    unpack_folder = config.get(u'mailpacket', u'unpack')

    assert os.path.isdir(inbound_folder)

    for file_path_zip in glob.glob(os.path.join(inbound_folder, u'*.*')):
        # Uncompress packet bundles, then loop to read packet/message headers/messages
        try:
            with zipfile.ZipFile(file_path_zip) as zip_obj:
                zip_obj.extractall(unpack_folder)

            packet_path = os.path.join(unpack_folder, u'*.pkt')
            print packet_path
            assert os.path.isdir(unpack_folder)

            total_message_count = 0

            for file_name in os.listdir(unpack_folder):
                # Parse Each Packet for the Header first.
                print u'Mail Packet: ' + file_name

                # Open then Parse Each Packet
                fido_object = open(os.path.join(unpack_folder, file_name), 'rb')

                try:
                    # make Sure we don't read past the end of the file!
                    packet_header_read = fido_object.read()[:58]
                except EOFError:
                    # move to next packet if were at the end.
                    break

                if not packet_header_read:
                    # move to next packet, log error here
                    break

                # Make sure we have correct size! Otherwise were done.
                # print 'packet_header_read len: ' + str(len(packet_header_read))
                if len(packet_header_read) < 58:
                    # End of File can have (2) Bytes, catch this.
                    break

                # Read the Packet Header
                fido_header = FidonetPacketHeader(
                    *struct.unpack(_struct_fidonet_packet, packet_header_read))

                assert isinstance(fido_header, object)
                print fido_header

                message_count = 0

                offset = struct.calcsize(_struct_fidonet_packet)
                while True:

                    # Reset Position to right after Fido Header
                    fido_object.seek(offset)

                    # Try to parse the message header
                    try:
                        # make Sure we don't read past the end of the file!
                        message_header_read = fido_object.read()[:14]
                    except EOFError:
                        # move to next packet if were at the end.
                        break

                    if not packet_header_read:
                        # move to next packet, log error here
                        break

                    # Make sure we have correct size! Otherwise were done.
                    # print 'message_header_read len: ' + str(len(message_header_read))
                    if len(message_header_read) < 14:
                        # End of File can have (2) Bytes, catch this.
                        break

                    # Read the Message Header
                    fido_message_header = FidonetMessageHeader(
                        *struct.unpack(_struct_fidonet_message_header, message_header_read))

                    assert isinstance(fido_message_header, object)
                    print fido_message_header

                    # Update The Offset
                    offset += struct.calcsize(_struct_fidonet_message_header)

                    # Next move back to the next position
                    """ Next we need to parse For '\x00' terminated strings.
                    ('20s', 'dateTime'),
                    ('36s', 'toUsername'),
                    ('36s', 'fromUsername'),
                    ('72s', 'subject')
                    """

                    # Use cleaner way to keep track of offset!!
                    date_time_string = read_cstring(fido_object, offset)
                    offset += len(date_time_string) + 1
                    print u'DateTime: ' + date_time_string

                    username_to = read_cstring(fido_object, offset)
                    offset += len(username_to) + 1
                    print u'To (UserName): ' + username_to

                    username_from = read_cstring(fido_object, offset)
                    offset += len(username_from) + 1
                    print u'From (UserName): ' + username_from

                    subject_string = read_cstring(fido_object, offset)
                    offset += len(subject_string) + 1
                    print u'Subject: ' + subject_string

                    # We now read the entire message up to null terminator
                    # some fields terminate with 0x9d, and start with
                    # ie AREA:%s \x0d or \r!
                    # Other fields start with \x01: Kludge Lines
                    # "\x01""PID:",5
                    # "\x01""MSGID:",7
                    # "\x01""REPLY:",7
                    # "\x01""FLAGS:",7
                    # "\x01""INTL",5
                    # "\x01""TOPT",5
                    # "\x01""FMPT",5
                    # SEEN-BY:
                    # "\01" "PATH: "
                    # if(flagsbuf[0])
                    # strcat((char *)flagsbuf,(char *)"\x0d");
                    # " * Origin: ",11
                    # TID

                    # Read in entire text of message (parse out after, kludge and tag/origin lines)
                    # message_list = read_message_text(fido_object, offset)
                    message_string = read_message_text(fido_object, offset)
                    offset += len(message_string) + 1
                    # print message_list

                    print Message(message_string, username_to, username_from, subject_string)

                    message_count += 1
                    total_message_count += 1

                # Cleanup for next run
                fido_object.close()
                print ''
                print u'Total Messages This Packet -> ' + str(message_count)
                print u'Total Messages Count       -> ' + str(total_message_count)

        finally:
            # Clear the unpack_folder here lateron, leave for testing, just overwrites!
            print u'Done'


if __name__ == '__main__':
    main()
