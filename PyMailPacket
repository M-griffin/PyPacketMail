#!/usr/bin/env python2.7
# vim: set fileencoding=<utf-8> :
""" PyMailPacket for x/84, http://github.com/jquast/x84
    (c) 2015 Michael Griffin <mrmisticismo@hotmail.com>
    http://github.com/m-griffin/PyMailPacket

    This is a FidoNet Echomail Scanner / Tosser for x84 bbs.
    This will mimic the basic functionality of Crashmail for
    Reading and Writing mail packets.
"""

__author__ = "Michael Griffin"
__copyright__ = "Copyright 2015"
__credits__ = ["Jeff Quast"]
__license__ = "MIT"
__version__ = "1.0.0"
__status__ = "Prototype"

import binascii
import ConfigParser
import collections
import zipfile
import struct
import glob
import sys
import os


_struct_packet_header_fields = [
    # Structure Size 58
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'year'),
    ('H', 'month'),
    ('H', 'day'),
    ('H', 'hour'),
    ('H', 'minute'),
    ('H', 'second'),
    ('H', 'baud'),
    ('H', 'packet_type'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('B', 'prod_code_low'),
    ('B', 'revision_major'),
    ('8s', 'password'),
    ('H', 'origin_zone'),
    ('H', 'destination_zone'),
    ('H', 'aux_network'),
    ('H', 'capWordA'),
    ('B', 'prod_code_hi'),
    ('B', 'pRevMinor'),
    ('H', 'capWordB'),
    ('H', 'origin_zone2'),
    ('H', 'destination_zone2'),
    ('H', 'origin_point'),
    ('H', 'destination_point'),
    ('L', 'prod_data')
]
_struct_fidonet_packet = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_packet_header_fields))
FidonetPacketHeader = collections.namedtuple(
    'FidonetPacketHeader', [field_name for _, field_name in _struct_packet_header_fields])

_struct_message_header_fields = [
    # Structure Size 14
    ('H', 'message_type'),
    ('H', 'origin_node'),
    ('H', 'destination_node'),
    ('H', 'origin_network'),
    ('H', 'destination_network'),
    ('H', 'attributes_flags'),
    ('H', 'cost'),
]
_struct_fidonet_message_header = '<{0}'.format(
    ''.join(struct_val for struct_val, _ in _struct_message_header_fields))
FidonetMessageHeader = collections.namedtuple(
    'FidonetMessageHeader', [field_name for _, field_name in _struct_message_header_fields])


def read_cstring(file_object, offset):
    # Function to read text up to null terminator
    newstr = ""
    # jump to offset.
    assert isinstance(offset, object)
    file_object.seek(offset)
    while True:
        # read the file object
        byte = file_object.read(1)
        if not byte:
            break
        if byte in '\x00':
            # Break on Null Terminated
            break

        newstr += str(byte)
    return newstr


def read_kstring(file_object, offset):
    # Function to read text up to terminator
    newstr = ""
    # jump to offset.
    assert isinstance(offset, object)
    file_object.seek(offset)
    while True:
        # read the file object
        byte = file_object.read(1)
        if not byte:
            break
        if byte in '0x9d':
            # Terminated with 157 for Kludge Lines
            break

        newstr += str(byte)
    return newstr

'''
The problem is we can't just place this text into a string
because of the binary characters, They seem to populate and
Display from a list perfectly fine, but not a string!
'''


def read_message_text(file_object, offset):
    # Function to read message text up to null terminator
    new_string = ""
    assert isinstance(offset, object)
    file_object.seek(offset)

    my_list = []
    for chunk in iter(lambda: file_object.read(1), ''):
        if chunk in '\x00':
            break
        # elif chunk in ('\x01', '\x9d', '0x9d'):

        my_list.append(chunk)

    return my_list


def main():
    # Get Path to Fido Packets from Config file.
    config = ConfigParser.ConfigParser()
    config.read(u'mailpacket.conf')
    inbound_folder = config.get(u'mailpacket', u'inbound')
    unpack_folder = config.get(u'mailpacket', u'unpack')

    assert os.path.isdir(inbound_folder)

    for filepath_zip in glob.glob(os.path.join(inbound_folder, u'*.*')):
        # Uncompress packet bundles, then loop to read packet/message headers/messages
        try:
            with zipfile.ZipFile(filepath_zip) as zip_obj:
                zip_obj.extractall(unpack_folder)

            packet_path = os.path.join(unpack_folder, u'*.pkt')
            print packet_path
            assert os.path.isdir(unpack_folder)

            for file_name in os.listdir(unpack_folder):
                # Parse Each Packet for the Header first.
                print u'Mail Packet: ' + file_name

                # loop Each message inside of a packet
                fido_object = open(os.path.join(unpack_folder, file_name), 'rb')

                try:
                    # make Sure we don't read past the end of the file!
                    packet_header_read = fido_object.read()[:58]
                except EOFError:
                        # move to next packet if were at the end.
                        break
                    
                if not packet_header_read:                    
                    break

                # Make sure we have correct size! Otherwise were done.
                print 'packet_header_read len: ' + str(len(packet_header_read))
                if len(packet_header_read) < 58:
                        break

                

                fido_header = FidonetPacketHeader(
                    *struct.unpack(_struct_fidonet_packet, packet_header_read))

                assert isinstance(fido_header, object)
                print fido_header

                offset = struct.calcsize(_struct_fidonet_packet)
                while True:

                    # Reset Position to right after Fido Header
                    fido_object.seek(offset)

                    # Try to parse the message header
                    try:
                        # make Sure we don't read past the end of the file!
                        message_header_read = fido_object.read()[:14]
                    except EOFError:
                        # move to next packet if were at the end.
                        break

                    if not packet_header_read:                    
                    break
                    
                    # Make sure we have correct size! Otherwise were done.
                    print 'message_header_read len: ' + str(len(message_header_read))
                    if len(message_header_read) < 14:
                        break

                    fido_message_header = FidonetMessageHeader(
                        *struct.unpack(_struct_fidonet_message_header, message_header_read))

                    assert isinstance(fido_message_header, object)
                    print fido_message_header

                    # Update The Offset
                    offset += struct.calcsize(_struct_fidonet_message_header)

                    # Next move back to the next position

                    """ Next we need to parse For '\x00' terminated strings.
                    ('20s', 'dateTime'),
                    ('36s', 'toUsername'),
                    ('36s', 'fromUsername'),
                    ('72s', 'subject')
                    """

                    # Use cleaner way to keep track of offset!!
                    newstr = read_cstring(fido_object, offset)
                    offset += len(newstr) + 1
                    print u'DateTime: ' + newstr


                    newstr = read_cstring(fido_object, offset)
                    offset += len(newstr) + 1
                    print u'To (UserName): ' + newstr

                    newstr = read_cstring(fido_object, offset)
                    offset += len(newstr) + 1
                    print u'From (UserName): ' + newstr

                    newstr = read_cstring(fido_object, offset)
                    offset += len(newstr) + 1
                    print u'Subject: ' + newstr

                    # We now read the entire message up to null terminator
                    # some fields terminate with 0x9d, and start with
                    # ie AREA:%s\x0d
                    # Other fields : Kludge Lines
                    # "\x01""PID:",5
                    # "\x01""MSGID:",7
                    # "\x01""REPLY:",7
                    # "\x01""FLAGS:",7
                    # "\x01""INTL",5
                    # "\x01""TOPT",5
                    # "\x01""FMPT",5
                    # SEEN-BY:
                    # "\01" "PATH: "
                    # if(flagsbuf[0])
                    # strcat((char *)flagsbuf,(char *)"\x0d");
                    # " * Origin: ",11
                    # TID

                    '''
                    newstr = fido_object.read(200)
                    offset += 200
                    fido_object.seek(offset)

                    sys.stdout.write(newstr)
                    print ''
                    '''

                    message_list = read_message_text(fido_object, offset)
                    offset += len(message_list) + 1
                    print message_list

                # Cleanup for next run
                fido_object.close()

        finally:
            # Clear the unpack_folder here lateron, leave for testing, just overwrites!
            print u'Done'


if __name__ == '__main__':
    main()
